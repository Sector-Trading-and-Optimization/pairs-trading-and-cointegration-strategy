# -*- coding: utf-8 -*-
"""ols.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/173-jpQqYFPzNe2qpJu7D-Do-_1Pi5siu
"""

!pip install yfinance

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import datetime
import yfinance as yf
import statsmodels.api as sm
from statsmodels.regression.linear_model import OLS
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.stattools import coint
from sklearn.model_selection import train_test_split

companies=pd.DataFrame()
stocks=["AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", "JPM", "WMT", "JNJ", "V", "PG", "KO", "NFLX", "DIS", "NVDA", "VZ", "T", "IBM", "HD","BA","MA"]
for stock in stocks:
    stk=yf.Ticker(stock)
    data=stk.history(start='2017-06-01',end='2023-07-31')
    companies[stock]=data['Close']
companies.head()

train_close, test_close = train_test_split(companies, test_size=0.5, shuffle=False)

fig, ax = plt.subplots(figsize=(20,14))
sns.heatmap(train_close.pct_change().corr(method ='pearson'), ax=ax, cmap='coolwarm', annot=True, fmt=".3f")
ax.set_title('Assets Correlation Matrix')

def find_cointegrated_pairs(data):
    n = data.shape[1]
    pvalue_matrix = np.ones((n, n))
    keys = data.keys()
    pairs = []
    for i in range(n):
        for j in range(i+1, n):
            result = coint(data[keys[i]], data[keys[j]])
            pvalue_matrix[i, j] = result[1]
            if result[1] < 0.05:
                pairs.append((keys[i], keys[j]))
    return pvalue_matrix, pairs
pvalues, pairs = find_cointegrated_pairs(train_close)
print(pairs)

asset1,asset2='JNJ','V'
train = pd.DataFrame()
train['asset1'] = train_close[asset1]
train['asset2'] = train_close[asset2]
ax = train[['asset1','asset2']].plot(figsize=(12, 6), title = 'Daily Closing Prices for {} and {}'.format(asset1,asset2))
ax.set_ylabel("Closing Price")
ax.grid(True);

plt.figure(figsize=(14, 6))
stock1_close_relative = companies[asset1] / companies[asset1].iloc[0]
stock2_close_relative = companies[asset2]/ companies[asset2].iloc[0]
plt.plot(stock1_close_relative , label = asset1 )
plt.plot(stock2_close_relative , label = asset2 )
plt.xlabel("Time")
plt.ylabel("Rel Close Price")
plt.legend()
plt.show()

start = '2017-06-01' #START DATE
end = '2023-07-31'  #END DATE

name_stock1 = "JNJ"
name_stock2 = "V"

stock1 = yf.Ticker(name_stock1)
stock2 = yf.Ticker(name_stock2)

#USING THE DATASET OF DAILY STOCK PRICES
stock1_data = stock1.history(interval = '1d' , start = start , end = end)
stock2_data = stock2.history(interval = '1d' , start = start , end = end)



Y = np.log(stock2_data["Close"]) #TAKING LOGARITHM OF THE CLOSE PRICE OF STOCK 2
X = np.log(stock1_data["Close"]) #TAKING LOGARITHM OF THE CLOSE PRICE OF STOCK 1
X = sm.add_constant(X)  #ADDING A CONSTANT WHICH IS THE INTERCEPT
model = sm.OLS(Y,X)  #FITTING THE LINEAR REGRESSING MODEL
results = model.fit()
results.params

beta = results.params.values[1]  #EXTRACTS THE SLOPE OF THE LR
errors = Y - (X["Close"]*beta)

plt.figure(figsize=(14, 6))

errors.plot(label=f"x = {name_stock1}; y = {name_stock2} \n{name_stock2} - {name_stock1}")
plt.title(f'Residuals from spread \nSpread = {name_stock2} + {beta:.2f}*{name_stock1})', fontsize=10)
plt.xlabel("Time")
plt.ylabel("Values")
plt.legend()
plt.show()


spread = errors
zscore = (spread-np.mean(spread)) / np.std(spread)

plt.figure(figsize=(14, 6))
zscore.plot(label='z-score')
plt.title(f"z-score {name_stock2}-{name_stock1}")
plt.xlabel("Time")
plt.ylabel("Values")
plt.axhline(y=1, color='b', label='1 threshold')
plt.axhline(y=-1, color='b', label='-1 threshold')
plt.legend()
plt.show()

def generate_trade_signals(S1, S2, spread, zscore):
    trades = pd.DataFrame({
        'price1': S1,
        'price2': S2,
        'spread': spread,
        'zscore': zscore
    })
    trades.dropna(inplace=True)
    trades['signal1'] = np.where(trades['zscore'] > 1, -1, np.where(trades['zscore'] < -1, 1, 0))
    trades['signal2'] = -trades['signal1']
    trades['position1'] = trades['signal1'].diff().apply(lambda x: 0 if abs(x) > 1 else x)
    trades['position2'] = trades['signal2'].diff().apply(lambda x: 0 if abs(x) > 1 else x)
    return trades

trade_signals = generate_trade_signals(companies[asset2], companies[asset1], spread, zscore).dropna()

def show_trade_signals(data):
    fig = plt.figure(figsize=(14, 6))
    ax = fig.add_subplot(111)
    ax.plot(data['zscore'], color='#4abdac')
    ax.plot(data['zscore'][data['position1'] == 1], lw=0, marker='^', c='g', markersize=8, alpha=0.9)
    ax.plot(data['zscore'][data['position1'] == -1], lw=0, marker='v', c='r', markersize=8, alpha=0.9)
    plt.title(f'{name_stock2} vs {name_stock1}')
    plt.legend(['Z-Score', 'Buy', 'Sell'])
    plt.show()

show_trade_signals(trade_signals)

def pnl_calculation(signals):

  initial_capital = 50000

  # Shares to buy for each stock
  shares1 = initial_capital// (signals['price1'][0])
  shares2 = initial_capital// (signals['price2'][0])

  #PnL for stock 1
  portfolio = pd.DataFrame()
  portfolio['holdings1'] = signals['position1'].cumsum() * signals['price1'] * shares1
  portfolio['cash1'] = initial_capital - (signals['position1'] * signals['price1'] * shares1).cumsum()
  portfolio['total1'] = portfolio['holdings1'] + portfolio['cash1']
  portfolio['return1'] = portfolio['total1'].pct_change()

  # PnL for stock 2
  portfolio['holdings2'] = signals['position2'].cumsum() * signals['price2'] * shares2
  portfolio['cash2'] = initial_capital - (signals['position2'] * signals['price2'] * shares2).cumsum()
  portfolio['total2'] = portfolio['holdings2'] + portfolio['cash2']
  portfolio['return2'] = portfolio['total2'].pct_change()

  # Total PnL
  portfolio['total'] = portfolio['total1'] + portfolio['total2']
  portfolio = portfolio.dropna()

  return portfolio

portfolio = pnl_calculation(trade_signals)
portfolio.head()
     
def plot_portfolio_value(portfolio):
  fig = plt.figure(figsize=(14,6),)
  ax = fig.add_subplot(111)
  l1, = ax.plot(portfolio['total'], c='g')
  ax.set_ylabel('Asset Value')
  ax.yaxis.labelpad=15
  ax.set_xlabel('Date')
  ax.xaxis.labelpad=15
  plt.title('Portfolio Performance PnL')
  plt.legend(['Total Portfolio Value'])
     

plot_portfolio_value(portfolio)
